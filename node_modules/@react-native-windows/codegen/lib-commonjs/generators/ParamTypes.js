/**
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 * @format
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateArgs = exports.translateSpecArgs = void 0;
const AliasManaging_1 = require("./AliasManaging");
function decorateType(type, target) {
    switch (target) {
        case 'method-arg':
            return `${type} &&`;
        case 'callback-arg':
            return `${type} const &`;
        default:
            return type;
    }
}
function translateParam(param, aliases, baseAliasName, target) {
    // avoid: Property 'type' does not exist on type 'never'
    const paramType = param.type;
    switch (param.type) {
        case 'StringTypeAnnotation':
            return 'std::string';
        case 'NumberTypeAnnotation':
        case 'FloatTypeAnnotation':
        case 'DoubleTypeAnnotation':
            return 'double';
        case 'Int32TypeAnnotation':
            return 'int';
        case 'BooleanTypeAnnotation':
            return 'bool';
        case 'FunctionTypeAnnotation': {
            // TODO: type.returnTypeAnnotation
            switch (target) {
                case 'spec':
                    return `Callback<${param.params
                        .map((p) => translateSpecFunctionParam(p, aliases, `${baseAliasName}_${p.name}`))
                        .join(', ')}>`;
                case 'template':
                    return `std::function<void(${param.params
                        .map((p) => translateCallbackParam(p, aliases, `${baseAliasName}_${p.name}`))
                        .join(', ')})>`;
                default:
                    return `std::function<void(${param.params
                        .map((p) => translateCallbackParam(p, aliases, `${baseAliasName}_${p.name}`))
                        .join(', ')})> const &`;
            }
        }
        case 'ArrayTypeAnnotation':
            if (param.elementType) {
                switch (target) {
                    case 'spec':
                    case 'template':
                        return `std::vector<${translateNullableParamType(param.elementType, aliases, `${baseAliasName}_element`, 'template', 'template')}>`;
                    default:
                        return `std::vector<${translateNullableParamType(param.elementType, aliases, `${baseAliasName}_element`, 'template', 'template')}> const &`;
                }
            }
            else {
                return decorateType('::React::JSValueArray', target);
            }
        case 'GenericObjectTypeAnnotation':
            return decorateType('::React::JSValue', target);
        case 'ObjectTypeAnnotation':
            return decorateType((0, AliasManaging_1.getAnonymousAliasCppName)(aliases, baseAliasName, param), target);
        case 'ReservedTypeAnnotation': {
            // avoid: Property 'name' does not exist on type 'never'
            const name = param.name;
            // (#6597)
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (name !== 'RootTag')
                throw new Error(`Unknown reserved function: ${name} in translateParam`);
            return 'double';
        }
        case 'TypeAliasTypeAnnotation':
            return decorateType((0, AliasManaging_1.getAliasCppName)(param.name), target);
        default:
            throw new Error(`Unhandled type in translateParam: ${paramType}`);
    }
}
function translateNullableParamType(paramType, aliases, baseAliasName, nullableTarget, target) {
    switch (paramType.type) {
        case 'NullableTypeAnnotation':
            return `std::optional<${translateParam(paramType.typeAnnotation, aliases, baseAliasName, nullableTarget)}>`;
        default:
            return translateParam(paramType, aliases, baseAliasName, target);
    }
}
function translateSpecFunctionParam(param, aliases, baseAliasName) {
    return translateNullableParamType(param.typeAnnotation, aliases, baseAliasName, 'spec', 'spec');
}
function translateCallbackParam(param, aliases, baseAliasName) {
    return translateNullableParamType(param.typeAnnotation, aliases, baseAliasName, 'template', 'callback-arg');
}
function translateFunctionParam(param, aliases, baseAliasName) {
    return translateNullableParamType(param.typeAnnotation, aliases, baseAliasName, 'template', 'method-arg');
}
function translateSpecArgs(params, aliases, baseAliasName) {
    return params.map(param => {
        const translatedParam = translateSpecFunctionParam(param, aliases, `${baseAliasName}_${param.name}`);
        return `${translatedParam}`;
    });
}
exports.translateSpecArgs = translateSpecArgs;
function translateArgs(params, aliases, baseAliasName) {
    return params.map(param => {
        const translatedParam = translateFunctionParam(param, aliases, `${baseAliasName}_${param.name}`);
        return `${translatedParam} ${param.name}`;
    });
}
exports.translateArgs = translateArgs;
//# sourceMappingURL=ParamTypes.js.map