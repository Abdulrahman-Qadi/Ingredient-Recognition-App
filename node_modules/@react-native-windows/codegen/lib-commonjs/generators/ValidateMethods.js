/**
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 * @format
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateValidateMethods = void 0;
const ParamTypes_1 = require("./ParamTypes");
const ReturnTypes_1 = require("./ReturnTypes");
function isMethodSync(funcType) {
    return (funcType.returnTypeAnnotation.type !== 'VoidTypeAnnotation' &&
        funcType.returnTypeAnnotation.type !== 'PromiseTypeAnnotation');
}
function isMethodReturnPromise(funcType) {
    return funcType.returnTypeAnnotation.type === 'PromiseTypeAnnotation';
}
function getPossibleMethodSignatures(prop, funcType, aliases, baseAliasName) {
    const args = (0, ParamTypes_1.translateArgs)(funcType.params, aliases, baseAliasName);
    if (isMethodReturnPromise(funcType)) {
        // TODO: type of the promise could be provided in the future
        args.push('::React::ReactPromise<::React::JSValue> &&result');
    }
    // TODO: be much more exhastive on the possible method signatures that can be used..
    const sig = `REACT_${isMethodSync(funcType) ? 'SYNC_' : ''}METHOD(${prop.name}) ${(0, ReturnTypes_1.translateImplReturnType)(funcType.returnTypeAnnotation, aliases, baseAliasName)} ${prop.name}(${args.join(', ')}) noexcept { /* implementation */ }`;
    const staticsig = `REACT_${isMethodSync(funcType) ? 'SYNC_' : ''}METHOD(${prop.name}) static ${(0, ReturnTypes_1.translateImplReturnType)(funcType.returnTypeAnnotation, aliases, baseAliasName)} ${prop.name}(${args.join(', ')}) noexcept { /* implementation */ }`;
    return [sig, staticsig];
}
function translatePossibleMethodSignatures(prop, funcType, aliases, baseAliasName) {
    return getPossibleMethodSignatures(prop, funcType, aliases, baseAliasName)
        .map(sig => `"    ${sig}\\n"`)
        .join('\n          ');
}
function renderProperties(properties, aliases, tuple) {
    // TODO: generate code for constants
    return properties
        .filter(prop => prop.name !== 'getConstants')
        .map((prop, index) => {
        // TODO: prop.optional === true
        // TODO: prop.typeAnnotation.type === 'NullableTypeAnnotation'
        const propAliasName = prop.name;
        const funcType = prop.typeAnnotation.type === 'NullableTypeAnnotation'
            ? prop.typeAnnotation.typeAnnotation
            : prop.typeAnnotation;
        const traversedArgs = (0, ParamTypes_1.translateSpecArgs)(funcType.params, aliases, propAliasName);
        const translatedReturnParam = (0, ReturnTypes_1.translateSpecReturnType)(funcType.returnTypeAnnotation, aliases, propAliasName);
        if (isMethodReturnPromise(funcType)) {
            // TODO: type of the promise could be provided in the future
            traversedArgs.push('Promise<::React::JSValue>');
        }
        if (tuple) {
            return `      ${isMethodSync(funcType) ? 'Sync' : ''}Method<${translatedReturnParam}(${traversedArgs.join(', ')}) noexcept>{${index}, L"${prop.name}"},`;
        }
        else {
            return `    REACT_SHOW_METHOD_SPEC_ERRORS(
          ${index},
          "${prop.name}",
          ${translatePossibleMethodSignatures(prop, funcType, aliases, propAliasName)});`;
        }
    })
        .join('\n');
}
function generateValidateMethods(nativeModule, aliases) {
    const properties = nativeModule.spec.properties;
    const traversedProperties = renderProperties(properties, aliases, false);
    const traversedPropertyTuples = renderProperties(properties, aliases, true);
    return [traversedPropertyTuples, traversedProperties];
}
exports.generateValidateMethods = generateValidateMethods;
//# sourceMappingURL=ValidateMethods.js.map