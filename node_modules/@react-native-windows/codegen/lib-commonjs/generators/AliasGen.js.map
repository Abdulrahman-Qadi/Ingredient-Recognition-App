{"version":3,"file":"AliasGen.js","sourceRoot":"","sources":["../../src/generators/AliasGen.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n * @format\n */\n\n'use strict';\n\nimport type {\n  NativeModuleBaseTypeAnnotation,\n  NativeModuleObjectTypeAnnotation,\n  NamedShape,\n  Nullable,\n} from 'react-native-tscodegen';\nimport {AliasMap, getAliasCppName} from './AliasManaging';\nimport {translateField} from './ObjectTypes';\n\nfunction translateObjectBody(\n  type: NativeModuleObjectTypeAnnotation,\n  aliases: AliasMap,\n  baseAliasName: string,\n  prefix: string,\n) {\n  return type.properties\n    .map((prop: NamedShape<Nullable<NativeModuleBaseTypeAnnotation>>) => {\n      let propType = prop.typeAnnotation;\n      if (prop.optional && propType.type !== 'NullableTypeAnnotation') {\n        propType = {type: 'NullableTypeAnnotation', typeAnnotation: propType};\n      }\n      const first = `${prefix}REACT_FIELD(${prop.name})`;\n      const second = `${prefix}${translateField(\n        propType,\n        aliases,\n        `${baseAliasName}_${prop.name}`,\n      )} ${prop.name};`;\n      return `${first}\\n${second}`;\n    })\n    .join('\\n');\n}\n\nexport function createAliasMap(nativeModuleAliases: {\n  [name: string]: NativeModuleObjectTypeAnnotation;\n}): AliasMap {\n  const aliases: AliasMap = {types: {}, jobs: Object.keys(nativeModuleAliases)};\n  for (const aliasName of aliases.jobs) {\n    aliases.types[aliasName] = nativeModuleAliases[aliasName];\n  }\n  return aliases;\n}\n\ninterface AliasCodeMap {\n  [name: string]: string;\n}\n\nfunction generateSingleAlias(\n  aliases: AliasMap,\n  aliasName: string,\n  aliasCode: AliasCodeMap,\n): void {\n  const aliasType = <NativeModuleObjectTypeAnnotation>aliases.types[aliasName];\n  aliasCode[aliasName] = `\nREACT_STRUCT(${getAliasCppName(aliasName)})\nstruct ${getAliasCppName(aliasName)} {\n${translateObjectBody(aliasType, aliases, aliasName, '    ')}\n};\n`;\n}\n\nfunction generateNestedAliasesInCorrectOrder(\n  aliases: AliasMap,\n  aliasCode: AliasCodeMap,\n  aliasOrder: string[],\n): void {\n  // retrieve and clean all ungenerated aliases\n  const jobs = aliases.jobs;\n  aliases.jobs = [];\n\n  // generate each one in its found order\n  for (const aliasName of jobs) {\n    // generate a new struct and all fields will be examined\n    // new anonymous objects could be found\n    // they will be stored in aliases.jobs\n    generateSingleAlias(aliases, aliasName, aliasCode);\n    // nested C++ structs must be put before the current C++ struct\n    // as they will be used in the current C++ struct\n    // the order will be perfectly and easily ensured by doing this recursively\n    generateNestedAliasesInCorrectOrder(aliases, aliasCode, aliasOrder);\n    // all referenced C++ structs are generated\n    // put the current one following them\n    aliasOrder.push(aliasName);\n  }\n}\n\nexport function generateAliases(aliases: AliasMap): string {\n  const aliasCode: AliasCodeMap = {};\n  const aliasOrder: string[] = [];\n  generateNestedAliasesInCorrectOrder(aliases, aliasCode, aliasOrder);\n\n  // aliasOrder now has the correct order of C++ struct code\n  let traversedAliasedStructs = '';\n  for (const aliasName of aliasOrder) {\n    traversedAliasedStructs = `${traversedAliasedStructs}${aliasCode[aliasName]}`;\n  }\n  return traversedAliasedStructs;\n}\n"]}