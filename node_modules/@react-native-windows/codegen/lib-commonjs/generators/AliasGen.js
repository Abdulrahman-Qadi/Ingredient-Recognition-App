/**
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 * @format
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAliases = exports.createAliasMap = void 0;
const AliasManaging_1 = require("./AliasManaging");
const ObjectTypes_1 = require("./ObjectTypes");
function translateObjectBody(type, aliases, baseAliasName, prefix) {
    return type.properties
        .map((prop) => {
        let propType = prop.typeAnnotation;
        if (prop.optional && propType.type !== 'NullableTypeAnnotation') {
            propType = { type: 'NullableTypeAnnotation', typeAnnotation: propType };
        }
        const first = `${prefix}REACT_FIELD(${prop.name})`;
        const second = `${prefix}${(0, ObjectTypes_1.translateField)(propType, aliases, `${baseAliasName}_${prop.name}`)} ${prop.name};`;
        return `${first}\n${second}`;
    })
        .join('\n');
}
function createAliasMap(nativeModuleAliases) {
    const aliases = { types: {}, jobs: Object.keys(nativeModuleAliases) };
    for (const aliasName of aliases.jobs) {
        aliases.types[aliasName] = nativeModuleAliases[aliasName];
    }
    return aliases;
}
exports.createAliasMap = createAliasMap;
function generateSingleAlias(aliases, aliasName, aliasCode) {
    const aliasType = aliases.types[aliasName];
    aliasCode[aliasName] = `
REACT_STRUCT(${(0, AliasManaging_1.getAliasCppName)(aliasName)})
struct ${(0, AliasManaging_1.getAliasCppName)(aliasName)} {
${translateObjectBody(aliasType, aliases, aliasName, '    ')}
};
`;
}
function generateNestedAliasesInCorrectOrder(aliases, aliasCode, aliasOrder) {
    // retrieve and clean all ungenerated aliases
    const jobs = aliases.jobs;
    aliases.jobs = [];
    // generate each one in its found order
    for (const aliasName of jobs) {
        // generate a new struct and all fields will be examined
        // new anonymous objects could be found
        // they will be stored in aliases.jobs
        generateSingleAlias(aliases, aliasName, aliasCode);
        // nested C++ structs must be put before the current C++ struct
        // as they will be used in the current C++ struct
        // the order will be perfectly and easily ensured by doing this recursively
        generateNestedAliasesInCorrectOrder(aliases, aliasCode, aliasOrder);
        // all referenced C++ structs are generated
        // put the current one following them
        aliasOrder.push(aliasName);
    }
}
function generateAliases(aliases) {
    const aliasCode = {};
    const aliasOrder = [];
    generateNestedAliasesInCorrectOrder(aliases, aliasCode, aliasOrder);
    // aliasOrder now has the correct order of C++ struct code
    let traversedAliasedStructs = '';
    for (const aliasName of aliasOrder) {
        traversedAliasedStructs = `${traversedAliasedStructs}${aliasCode[aliasName]}`;
    }
    return traversedAliasedStructs;
}
exports.generateAliases = generateAliases;
//# sourceMappingURL=AliasGen.js.map