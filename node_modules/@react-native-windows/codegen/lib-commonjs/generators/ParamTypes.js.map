{"version":3,"file":"ParamTypes.js","sourceRoot":"","sources":["../../src/generators/ParamTypes.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n * @format\n */\n\n'use strict';\n\nimport type {\n  NamedShape,\n  NativeModuleParamTypeAnnotation,\n  Nullable,\n} from 'react-native-tscodegen';\nimport {\n  AliasMap,\n  getAliasCppName,\n  getAnonymousAliasCppName,\n} from './AliasManaging';\n\ntype NativeModuleParamShape = NamedShape<\n  Nullable<NativeModuleParamTypeAnnotation>\n>;\n\ntype ParamTarget = 'spec' | 'template' | 'callback-arg' | 'method-arg';\n\nfunction decorateType(type: string, target: ParamTarget): string {\n  switch (target) {\n    case 'method-arg':\n      return `${type} &&`;\n    case 'callback-arg':\n      return `${type} const &`;\n    default:\n      return type;\n  }\n}\n\nfunction translateParam(\n  param: NativeModuleParamTypeAnnotation,\n  aliases: AliasMap,\n  baseAliasName: string,\n  target: ParamTarget,\n): string {\n  // avoid: Property 'type' does not exist on type 'never'\n  const paramType = param.type;\n  switch (param.type) {\n    case 'StringTypeAnnotation':\n      return 'std::string';\n    case 'NumberTypeAnnotation':\n    case 'FloatTypeAnnotation':\n    case 'DoubleTypeAnnotation':\n      return 'double';\n    case 'Int32TypeAnnotation':\n      return 'int';\n    case 'BooleanTypeAnnotation':\n      return 'bool';\n    case 'FunctionTypeAnnotation': {\n      // TODO: type.returnTypeAnnotation\n      switch (target) {\n        case 'spec':\n          return `Callback<${param.params\n            .map((p: NativeModuleParamShape) =>\n              translateSpecFunctionParam(\n                p,\n                aliases,\n                `${baseAliasName}_${p.name}`,\n              ),\n            )\n            .join(', ')}>`;\n        case 'template':\n          return `std::function<void(${param.params\n            .map((p: NativeModuleParamShape) =>\n              translateCallbackParam(p, aliases, `${baseAliasName}_${p.name}`),\n            )\n            .join(', ')})>`;\n        default:\n          return `std::function<void(${param.params\n            .map((p: NativeModuleParamShape) =>\n              translateCallbackParam(p, aliases, `${baseAliasName}_${p.name}`),\n            )\n            .join(', ')})> const &`;\n      }\n    }\n    case 'ArrayTypeAnnotation':\n      if (param.elementType) {\n        switch (target) {\n          case 'spec':\n          case 'template':\n            return `std::vector<${translateNullableParamType(\n              param.elementType,\n              aliases,\n              `${baseAliasName}_element`,\n              'template',\n              'template',\n            )}>`;\n          default:\n            return `std::vector<${translateNullableParamType(\n              param.elementType,\n              aliases,\n              `${baseAliasName}_element`,\n              'template',\n              'template',\n            )}> const &`;\n        }\n      } else {\n        return decorateType('::React::JSValueArray', target);\n      }\n    case 'GenericObjectTypeAnnotation':\n      return decorateType('::React::JSValue', target);\n    case 'ObjectTypeAnnotation':\n      return decorateType(\n        getAnonymousAliasCppName(aliases, baseAliasName, param),\n        target,\n      );\n    case 'ReservedTypeAnnotation': {\n      // avoid: Property 'name' does not exist on type 'never'\n      const name = param.name;\n      // (#6597)\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (name !== 'RootTag')\n        throw new Error(`Unknown reserved function: ${name} in translateParam`);\n      return 'double';\n    }\n    case 'TypeAliasTypeAnnotation':\n      return decorateType(getAliasCppName(param.name), target);\n    default:\n      throw new Error(`Unhandled type in translateParam: ${paramType}`);\n  }\n}\n\nfunction translateNullableParamType(\n  paramType: Nullable<NativeModuleParamTypeAnnotation>,\n  aliases: AliasMap,\n  baseAliasName: string,\n  nullableTarget: ParamTarget,\n  target: ParamTarget,\n): string {\n  switch (paramType.type) {\n    case 'NullableTypeAnnotation':\n      return `std::optional<${translateParam(\n        paramType.typeAnnotation,\n        aliases,\n        baseAliasName,\n        nullableTarget,\n      )}>`;\n    default:\n      return translateParam(paramType, aliases, baseAliasName, target);\n  }\n}\n\nfunction translateSpecFunctionParam(\n  param: NativeModuleParamShape,\n  aliases: AliasMap,\n  baseAliasName: string,\n): string {\n  return translateNullableParamType(\n    param.typeAnnotation,\n    aliases,\n    baseAliasName,\n    'spec',\n    'spec',\n  );\n}\n\nfunction translateCallbackParam(\n  param: NativeModuleParamShape,\n  aliases: AliasMap,\n  baseAliasName: string,\n): string {\n  return translateNullableParamType(\n    param.typeAnnotation,\n    aliases,\n    baseAliasName,\n    'template',\n    'callback-arg',\n  );\n}\n\nfunction translateFunctionParam(\n  param: NativeModuleParamShape,\n  aliases: AliasMap,\n  baseAliasName: string,\n): string {\n  return translateNullableParamType(\n    param.typeAnnotation,\n    aliases,\n    baseAliasName,\n    'template',\n    'method-arg',\n  );\n}\n\nexport function translateSpecArgs(\n  params: ReadonlyArray<NativeModuleParamShape>,\n  aliases: AliasMap,\n  baseAliasName: string,\n) {\n  return params.map(param => {\n    const translatedParam = translateSpecFunctionParam(\n      param,\n      aliases,\n      `${baseAliasName}_${param.name}`,\n    );\n    return `${translatedParam}`;\n  });\n}\n\nexport function translateArgs(\n  params: ReadonlyArray<NativeModuleParamShape>,\n  aliases: AliasMap,\n  baseAliasName: string,\n) {\n  return params.map(param => {\n    const translatedParam = translateFunctionParam(\n      param,\n      aliases,\n      `${baseAliasName}_${param.name}`,\n    );\n    return `${translatedParam} ${param.name}`;\n  });\n}\n"]}