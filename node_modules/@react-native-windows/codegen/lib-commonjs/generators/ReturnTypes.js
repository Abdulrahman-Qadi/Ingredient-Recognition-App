/**
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 * @format
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateImplReturnType = exports.translateSpecReturnType = void 0;
const AliasManaging_1 = require("./AliasManaging");
function translateReturnType(type, aliases, baseAliasName) {
    // avoid: Property 'type' does not exist on type 'never'
    const returnType = type.type;
    switch (type.type) {
        case 'VoidTypeAnnotation':
        case 'PromiseTypeAnnotation':
            return 'void';
        case 'StringTypeAnnotation':
            return 'std::string';
        case 'NumberTypeAnnotation':
        case 'FloatTypeAnnotation':
        case 'DoubleTypeAnnotation':
            return 'double';
        case 'Int32TypeAnnotation':
            return 'int';
        case 'BooleanTypeAnnotation':
            return 'bool';
        case 'ArrayTypeAnnotation':
            if (type.elementType) {
                return `std::vector<${translateReturnType(type.elementType, aliases, `${baseAliasName}_element`)}>`;
            }
            else {
                return '::React::JSValueArray';
            }
        case 'GenericObjectTypeAnnotation':
            return '::React::JSValue';
        case 'ObjectTypeAnnotation':
            return (0, AliasManaging_1.getAnonymousAliasCppName)(aliases, baseAliasName, type);
        case 'ReservedTypeAnnotation': {
            // avoid: Property 'name' does not exist on type 'never'
            const name = type.name;
            // (#6597)
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (name !== 'RootTag')
                throw new Error(`Unknown reserved function: ${name} in translateReturnType`);
            return 'double';
        }
        case 'TypeAliasTypeAnnotation':
            return (0, AliasManaging_1.getAliasCppName)(type.name);
        case 'NullableTypeAnnotation':
            return `std::optional<${translateReturnType(type.typeAnnotation, aliases, baseAliasName)}>`;
        default:
            throw new Error(`Unhandled type in translateReturnType: ${returnType}`);
    }
}
function translateSpecReturnType(type, aliases, baseAliasName) {
    return translateReturnType(type, aliases, `${baseAliasName}_returnType`);
}
exports.translateSpecReturnType = translateSpecReturnType;
function translateImplReturnType(type, aliases, baseAliasName) {
    return translateReturnType(type, aliases, `${baseAliasName}_returnType`);
}
exports.translateImplReturnType = translateImplReturnType;
//# sourceMappingURL=ReturnTypes.js.map