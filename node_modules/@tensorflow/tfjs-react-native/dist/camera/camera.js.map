{"version":3,"file":"camera.js","sourceRoot":"","sources":["../../src/camera/camera.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {downloadTextureData, drawTexture, runResizeProgram, uploadTextureData} from './camera_webgl_util';\nimport {Rotation} from './types';\ninterface Dimensions {\n  width: number;\n  height: number;\n  depth: number;\n}\n\ninterface Size {\n  width: number;\n  height: number;\n}\n\ninterface FromTextureOptions {\n  alignCorners?: boolean;\n  interpolation?: 'nearest_neighbor'|'bilinear';\n  rotation?: Rotation;\n}\n\nconst glCapabilities = {\n  canDownloadFromRGBTexture: new WeakMap<WebGL2RenderingContext, boolean>(),\n  // Has detectGLCapabilities been run on a particular GL context;\n  glCapabilitiesTested: new WeakMap<WebGL2RenderingContext, boolean>()\n};\n\n/**\n * Utility function that tests the GL context for capabilities to enable\n * optimizations.\n *\n * For best performance this should be be called once before using the other\n * camera related functions.\n *\n * @doc {heading: 'Media', subheading: 'Camera'}\n */\nexport async function detectGLCapabilities(gl: WebGL2RenderingContext) {\n  if (glCapabilities.glCapabilitiesTested.get(gl)) {\n    return;\n  }\n  // Test whether we can successfully download from an RGB texture.\n  // Notably this isn't supported on iOS, but we use this test rather than a\n  // platform check to be more robust on android devices we may not have\n  // directly tested.\n\n  // Set this to true temporarily so that fromTexture does not\n  // use its workaround.\n  glCapabilities.canDownloadFromRGBTexture.set(gl, true);\n\n  try {\n    const height = 2;\n    const width = 4;  // This must be a multiple of 4.\n    const data = new Uint8Array(height * width * 4);\n    for (let i = 0; i < data.length; i++) {\n      data[i] = i;\n    }\n    const sourceDims = {height, width, depth: 4};\n    const tex = uploadTextureData(data, gl, sourceDims);\n\n    const targetDims = {height, width, depth: 3};\n    const downloaded = fromTexture(gl, tex, sourceDims, targetDims);\n    const downloadedData = await downloaded.data();\n    tf.dispose(downloaded);\n\n    const matches = tf.util.arraysEqual(downloadedData, [\n      0,  1,  2,  4,  5,  6,  8,  9,  10, 12, 13, 14,\n      16, 17, 18, 20, 21, 22, 24, 25, 26, 28, 29, 30\n    ]);\n\n    if (matches) {\n      glCapabilities.canDownloadFromRGBTexture.set(gl, true);\n    } else {\n      glCapabilities.canDownloadFromRGBTexture.set(gl, false);\n    }\n  } catch (e) {\n    glCapabilities.canDownloadFromRGBTexture.set(gl, false);\n  } finally {\n    glCapabilities.glCapabilitiesTested.set(gl, true);\n  }\n}\n\n/**\n * Transfers tensor data to an RGB(A) texture.\n *\n * @param gl the WebGL context that owns the texture.\n * @param imageTensor the tensor to upload\n * @param texture optional the target texture. If none is passed in a new\n *     texture will be created.\n *\n * @doc {heading: 'Media', subheading: 'Camera'}\n */\nexport async function toTexture(\n    gl: WebGL2RenderingContext, imageTensor: tf.Tensor3D,\n    texture?: WebGLTexture): Promise<WebGLTexture> {\n  tf.util.assert(\n      imageTensor.dtype === 'int32', () => 'imageTensor must be of type int32');\n\n  tf.util.assert(\n      imageTensor.rank === 3, () => 'imageTensor must be a Tensor3D');\n\n  const imageData = Uint8Array.from(await imageTensor.data());\n  const dims = {\n    height: imageTensor.shape[0],\n    width: imageTensor.shape[1],\n    depth: imageTensor.shape[2],\n  };\n  return uploadTextureData(imageData, gl, dims, texture);\n}\n\n/**\n * Creates a tensor3D from a texture.\n *\n * Allows for resizing the image and dropping the alpha channel from the\n * resulting tensor.\n *\n * Note that if you the output depth is 3 then the output width should be a\n * multiple of 4.\n *\n * @param gl the WebGL context that owns the input texture\n * @param texture the texture to convert into a tensor\n * @param sourceDims source dimensions of input texture (width, height, depth)\n * @param targetShape desired shape of output tensor\n * @param useCustomShadersToResize whether to use custom shaders to resize\n *   texture.\n *\n * @doc {heading: 'Media', subheading: 'Camera'}\n */\nexport function fromTexture(\n    gl: WebGL2RenderingContext, texture: WebGLTexture, sourceDims: Dimensions,\n    targetShape: Dimensions, useCustomShadersToResize = false,\n    options: FromTextureOptions = {}): tf.Tensor3D {\n  tf.util.assert(\n      targetShape.depth === 3 || targetShape.depth === 4,\n      () => 'fromTexture Error: target depth must be 3 or 4');\n\n  if (targetShape.depth === 3 && targetShape.width % 4 !== 0) {\n    // We throw an error here rather than use the CPU workaround as the user is\n    // likely trying to get the maximum performance.\n    if (glCapabilities.canDownloadFromRGBTexture.get(gl)) {\n      // See\n      // https://www.khronos.org/opengl/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n      // for more details. At the moment gl.pixelStorei(gl.PACK_ALIGNMENT, 1);\n      // is not supported on expo. \"EXGL: gl.pixelStorei() doesn't support this\n      // parameter yet!\"\n      throw new Error(\n          'When using targetShape.depth=3, targetShape.width must be' +\n          ' a multiple of 4. Alternatively do not call detectGLCapabilities()');\n    }\n  }\n\n  const originalTargetDepth = targetShape.depth;\n  const targetDepth = glCapabilities.canDownloadFromRGBTexture.get(gl) ?\n      originalTargetDepth :\n      4;\n\n  sourceDims = {\n    height: Math.floor(sourceDims.height),\n    width: Math.floor(sourceDims.width),\n    depth: sourceDims.depth,\n  };\n\n  targetShape = {\n    height: Math.floor(targetShape.height),\n    width: Math.floor(targetShape.width),\n    depth: targetDepth\n  };\n\n  const alignCorners =\n      options.alignCorners != null ? options.alignCorners : false;\n  const interpolation =\n      options.interpolation != null ? options.interpolation : 'bilinear';\n  const rotation = options.rotation != null ? options.rotation : 0;\n\n  tf.util.assert(\n      interpolation === 'bilinear' || interpolation === 'nearest_neighbor',\n      () => 'fromTexture Error: interpolation must be one of' +\n          ' \"bilinear\" or \"nearest_neighbor\"');\n\n  tf.util.assert(\n      [0, 90, 180, 270, 360, -90, -180, -270].includes(rotation),\n      () => 'fromTexture Error: rotation must be ' +\n          '0, +/- 90, +/- 180, +/- 270 or 360');\n\n  const resizedTexture = runResizeProgram(\n      gl, texture, sourceDims, targetShape, alignCorners,\n      useCustomShadersToResize, interpolation, rotation);\n  const downloadedTextureData =\n      downloadTextureData(gl, resizedTexture, targetShape);\n\n  let finalTexData;\n  if (originalTargetDepth !== targetDepth && originalTargetDepth === 3) {\n    // We are on a device that does not support downloading from an RGB texture.\n    // Remove the alpha channel values on the CPU.\n    const area = targetShape.height * targetShape.width;\n    finalTexData = new Uint8Array(area * originalTargetDepth);\n\n    for (let i = 0; i < area; i++) {\n      const flatIndexRGB = i * 3;\n      const flatIndexRGBA = i * 4;\n      finalTexData[flatIndexRGB] = downloadedTextureData[flatIndexRGBA];\n      finalTexData[flatIndexRGB + 1] = downloadedTextureData[flatIndexRGBA + 1];\n      finalTexData[flatIndexRGB + 2] = downloadedTextureData[flatIndexRGBA + 2];\n    }\n  } else {\n    finalTexData = downloadedTextureData;\n  }\n\n  return tf.tensor3d(\n      finalTexData,\n      [targetShape.height, targetShape.width, originalTargetDepth], 'int32');\n}\n\n/**\n * Render a texture to the GLView. This will use the default framebuffer\n * and present the contents of the texture on the screen.\n *\n * @param gl\n * @param texture\n * @param dims Dimensions of tensor\n *\n * @doc {heading: 'Media', subheading: 'Camera'}\n */\nexport function renderToGLView(\n    gl: WebGL2RenderingContext, texture: WebGLTexture, size: Size,\n    flipHorizontal = true, rotation: Rotation = 0) {\n  tf.util.assert(\n      [0, 90, 180, 270, 360, -90, -180, -270].includes(rotation),\n      () => 'renderToGLView Error: rotation must be ' +\n          '0, +/- 90, +/- 180, +/- 270 or 360');\n\n  size = {\n    width: Math.floor(size.width),\n    height: Math.floor(size.height),\n  };\n  drawTexture(gl, texture, size, flipHorizontal, rotation);\n}\n"]}