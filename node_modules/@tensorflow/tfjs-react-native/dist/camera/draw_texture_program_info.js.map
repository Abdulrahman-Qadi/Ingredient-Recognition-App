{"version":3,"file":"draw_texture_program_info.js","sourceRoot":"","sources":["../../src/camera/draw_texture_program_info.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;GAeG;AAIH,MAAM,UAAU,kBAAkB,CAC9B,cAAuB,EAAE,YAAqB,EAAE,QAAkB;IACpE,MAAM,eAAe,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAChD,MAAM,aAAa,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5C,MAAM,WAAW,GAAG,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,GAAG,CAAC,CAAC;IACvE,OAAO;;;;;;;;;;;;;;;;;;;sCAmB6B,WAAW;;;uCAGV,eAAe,MAChD,aAAa;EACjB,CAAC;AACH,CAAC;AAED,MAAM,UAAU,oBAAoB;IAClC,OAAO;;;;;;;;EAQP,CAAC;AACH,CAAC;AAED,MAAM,UAAU,QAAQ;IACtB,OAAO,IAAI,YAAY,CAAC;QACtB,mBAAmB;QACnB,CAAC,CAAC,EAAE,CAAC,CAAC;QACN,CAAC,CAAC,EAAE,CAAC;QACL,CAAC,EAAE,CAAC;QACJ,CAAC,EAAE,CAAC;QACJ,CAAC,CAAC,EAAE,CAAC,CAAC;QACN,CAAC,EAAE,CAAC,CAAC;KAEN,CAAC,CAAC;AACL,CAAC;AAED,MAAM,UAAU,SAAS;IACvB,OAAO,IAAI,YAAY,CAAC;QACtB,mBAAmB;QACnB,CAAC,EAAE,CAAC;QACJ,CAAC,EAAE,CAAC;QACJ,CAAC,EAAE,CAAC;QACJ,CAAC,EAAE,CAAC;QACJ,CAAC,EAAE,CAAC;QACJ,CAAC,EAAE,CAAC;KAEL,CAAC,CAAC;AACL,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Rotation} from './types';\n\nexport function vertexShaderSource(\n    flipHorizontal: boolean, flipVertical: boolean, rotation: Rotation) {\n  const horizontalScale = flipHorizontal ? -1 : 1;\n  const verticalScale = flipVertical ? -1 : 1;\n  const rotateAngle = rotation === 0 ? '0.' : rotation * (Math.PI / 180);\n  return `#version 300 es\nprecision highp float;\n\nin vec2 position;\nin vec2 texCoords;\n\nout vec2 uv;\n\nvec2 rotate(vec2 uvCoods, vec2 pivot, float rotation) {\n  float cosa = cos(rotation);\n  float sina = sin(rotation);\n  uvCoods -= pivot;\n  return vec2(\n      cosa * uvCoods.x - sina * uvCoods.y,\n      cosa * uvCoods.y + sina * uvCoods.x\n  ) + pivot;\n}\n\nvoid main() {\n  uv = rotate(texCoords, vec2(0.5), ${rotateAngle});\n\n  // Invert geometry to match the image orientation from the camera.\n  gl_Position = vec4(position * vec2(${horizontalScale}., ${\n      verticalScale}. * -1.), 0, 1);\n}`;\n}\n\nexport function fragmentShaderSource() {\n  return `#version 300 es\nprecision highp float;\nuniform sampler2D inputTexture;\nin vec2 uv;\nout vec4 fragColor;\nvoid main() {\n  vec4 texSample = texture(inputTexture, uv);\n  fragColor = texSample;\n}`;\n}\n\nexport function vertices() {\n  return new Float32Array([\n    // clang-format off\n    -1, -1,\n    -1, 1,\n    1, 1,\n    1, 1,\n    -1, -1,\n    1, -1,\n    // clang-format on\n  ]);\n}\n\nexport function texCoords() {\n  return new Float32Array([\n    // clang-format off\n    0, 0,\n    0, 1,\n    1, 1,\n    1, 1,\n    0, 0,\n    1, 0,\n    // clang-format on\n  ]);\n}\n"]}