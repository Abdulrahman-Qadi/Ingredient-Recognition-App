{"version":3,"file":"decode_image.js","sourceRoot":"","sources":["../src/decode_image.ts"],"names":[],"mappings":"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","sourcesContent":["import {Tensor3D, tensor3d, util} from '@tensorflow/tfjs-core';\nimport * as jpeg from 'jpeg-js';\n\nenum ImageType {\n  JPEG = 'jpeg',\n  PNG = 'png',\n  GIF = 'gif',\n  BMP = 'BMP'\n}\n\n/**\n * Decode a JPEG-encoded image to a 3D Tensor of dtype `int32`.\n *\n * ```js\n * // Load an image as a Uint8Array\n * const imageUri = 'http://image-uri-here.example.com/image.jpg'; *\n * const response = await fetch(imageUri, {}, { isBinary: true });\n * const imageDataArrayBuffer = await response.arrayBuffer();\n * cosnt imageData = new Uint8Array(imageDataArrayBuffer);\n *\n * // Decode image data to a tensor\n * const imageTensor = decodeJpeg(imageData);\n * ```\n *\n * @param contents The JPEG-encoded image in an Uint8Array.\n * @param channels An optional int. Defaults to 3. Accepted values are\n *     0: use the number of channels in the JPG-encoded image.\n *     1: output a grayscale image.\n *     3: output an RGB image.\n * @returns A 3D Tensor of dtype `int32` with shape [height, width, 1/3].\n *\n * @doc {heading: 'Media', subheading: 'Images'}\n */\nexport function decodeJpeg(\n    contents: Uint8Array, channels: 0|1|3 = 3): Tensor3D {\n  util.assert(\n      getImageType(contents) === ImageType.JPEG,\n      () => 'The passed contents are not a valid JPEG image');\n  util.assert(\n      channels === 3, () => 'Only 3 channels is supported at this time');\n  const {width, height, data} = jpeg.decode(contents, {useTArray: true});\n  // Drop the alpha channel info because jpeg.decode always returns a typedArray\n  // with 255\n  const buffer = new Uint8Array(width * height * 3);\n  let offset = 0;  // offset into original data\n  for (let i = 0; i < buffer.length; i += 3) {\n    buffer[i] = data[offset];\n    buffer[i + 1] = data[offset + 1];\n    buffer[i + 2] = data[offset + 2];\n\n    offset += 4;\n  }\n\n  return tensor3d(buffer, [height, width, channels]);\n}\n\n/**\n * Helper function to get image type based on starting bytes of the image file.\n */\nfunction getImageType(content: Uint8Array): string {\n  // Classify the contents of a file based on starting bytes (aka magic number:\n  // tslint:disable-next-line:max-line-length\n  // https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files)\n  // This aligns with TensorFlow Core code:\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/4213d5c1bd921f8d5b7b2dc4bbf1eea78d0b5258/tensorflow/core/kernels/decode_image_op.cc#L44\n  if (content.length > 3 && content[0] === 255 && content[1] === 216 &&\n      content[2] === 255) {\n    // JPEG byte chunk starts with `ff d8 ff`\n    return ImageType.JPEG;\n  } else if (\n      content.length > 4 && content[0] === 71 && content[1] === 73 &&\n      content[2] === 70 && content[3] === 56) {\n    // GIF byte chunk starts with `47 49 46 38`\n    return ImageType.GIF;\n  } else if (\n      content.length > 8 && content[0] === 137 && content[1] === 80 &&\n      content[2] === 78 && content[3] === 71 && content[4] === 13 &&\n      content[5] === 10 && content[6] === 26 && content[7] === 10) {\n    // PNG byte chunk starts with `\\211 P N G \\r \\n \\032 \\n (89 50 4E 47 0D 0A\n    // 1A 0A)`\n    return ImageType.PNG;\n  } else if (content.length > 3 && content[0] === 66 && content[1] === 77) {\n    // BMP byte chunk starts with `42 4d`\n    return ImageType.BMP;\n  } else {\n    throw new Error(\n        'Expected image (JPEG, PNG, or GIF), but got unsupported image type');\n  }\n}\n"]}